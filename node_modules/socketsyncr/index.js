
try {

/* Import Node.js modules */
var sys = require("sys"),
	util = require('util'),
	http = require("http"),
	io = require("socket.io"),
	events = require('events'),
	url = require('url'),
	fs = require('fs');
	
	CLIENT_SIDE = false;

/* If we can't import these modules we're loaded on the client side */	
} catch(err) {
	if (err.message.indexOf('Cannot find module ') == 0) {
		CLIENT_SIDE = true;
	} else {
		throw err;
	}
}


var sync_event_ = 'sync_event_message_';

var syncable_event_ = 'syncable_event_'
var sync_id_ = 'sync_id_';


var syncable_changed_ = 'syncable_changed_';
var new_syncable_ = 'new_syncable_';
var initial_syncables_ = 'initial_syncables_';
var server_set_id_ = 'server_set_id_'



var temp_id_prefix = 'temp-id--'


var build_syncable_event_message = function(event,syncable,arguments) {
	return JSON.stringify({syncable_event_:event,
			'syncable':syncable
			'arguments':arguments
		})
}



/* SERVER_SIDE */
var SyncServer = this.SyncServer = function() {
	
	self = this;
	
	events.EventEmitter.call(this);
	
	this.listen = function(port) {
		self.httpServer.listen(port);
	}
	
	/* Setup HTTP server */
	this.httpServer = http.Server();
	
	/* Serve the socketsyncr client at /socketsyncr.js */
	this.httpServer.on('request' function(request,response) {
		if (request.url.parse(request.url).pathname == '/socketsyncr.js') {
			var body = fs.readFileSync('./node_modules/socketsyncr/index.js');
			response.writeHead(200, {
				'Content-Length':body.length,
				'Context-Type':'text/html'})
			})
			response.write(body)
			response.end()
		}
	})
	
	/* Setup socket.io server */
	this.socketServer = io.listen(this.httpServer);
	
	
	this.client_emitters = {};
	this.on('connection', function(client) {
		
		client.on('disconnect', function() {
			delete self.client_emitters[client.sessionId];
		});
		
		var emitter = self.client_emitters[client.sessionId] = events.EventEmitter()
		
		client.on('message',function(msg) {
			
			// Parse message as JSON object
			jso = JSON.parse(msg);
			
			
			/* If this is a generic sync event then re-emit it */
			if (jso[sync_event_]) {
				emitter.emit.apply(null,jso[sync_event_])
				
			}
				
				
			/* If this is a 'syncable' event... */
			} else if (jso[syncable_event_]) {
				
				
				sync_event = jso[syncable_event_]
				if (self.client_syncable_listeners[sync_event]) {
					args = [client]
					if (jso['syncable'])
						args.push(jso['syncable'])
					if (jso['arguments']) {
						for (i in jso['arguments']) {
							args.push(jso['arguments'][i])
						}
					}
					self.client_syncable_listeners[sync_event](args)
					
				}
			}	
		}	
		
		for (i in self.syncables) {
			client.send(
				build_syncable_event_message(new_syncable_,self.syncables[i])
			)
		}
		
	});
	

	
	
	/* GENERIC SYNC EVENTS */
	
	this.on_any_client = function(event,listener) {
		for (i in t.client_emitters) {
			this.on_client(event,listener,i)
		}
	}
	
	this.on_client = function(event,listener,client_session_id) {
		return self.client_emitters[client_session_id].on(event,listener)
	}
	
	this.forward_to_all = function(server_emitter, events) {
		for (i in this.socketServer.clients) {
			self.forward_to(server_emitter,events,i)
		}
	}
	
	this.forward_to = function(server_emitter, events, client_session_id) {
		if (typeof(events) == 'string') {
			events = [events]
		}
		for (j in events) {
			server_emitter.on(events[j], function() {
				arguments.unshift(client_session_id) // Push client_id to start of arg list
				self.send_as_event(arguments)
			})
		}
	}
	
	this.send_as_event = function() { // client_session_id, arg events
		client_session_id = arguments.shift()
		self.socketServer.clients[client_session_id].send(JSON.stringify({sync_event_:arguments}))
	}
	
	this.send_all_as_event = function() {
		for (i in self.socketServer.clients) {
			self.socketServer.clients[i].send(JSON.stringify({sync_event_:arguments}))		
		}
	}
	
	
	
	
	/* SYNCABLES */
	
	this.syncables = {}
	this.sync_id_next = 0
	
	/* 
	A ``syncable`` must subclass an EventEmitter. When a change to the ``syncable``
	object is made it should emit the `'change'` event--at which time the ``syncable``
	is forwarded to all clients. 
	
	When a change is made on a client the ``syncable`` object will have its `.changed()`
	method called with the client ``syncable`` object passed as the first argument. It
	is the responsibility of the ``syncable`` object to handle the changes properly.
	*/
	this.register = function(syncable,client) {
		
		self.syncables[self.sync_id_next] = syncable;
		syncable[sync_id_] = self.sync_id_next;
		
		syncable.on('change', function() {
			self.message_all_except(
				build_syncable_event_message(syncable_changed_,syncable), client.sessionId
			)
		})
		
		if (client) {
			self.message_all_except(
				build_syncable_event_message(new_syncable_,syncable), client.sessionId
			);
			self.message(
				build_syncable_event_message(server_set_id_,null,self.sync_id_next), client.sessionId
			)
			
		} else {
			sels.message_all(
				build_syncable_event_message(new_syncable_,syncable)
			);
		}
		
		self.sync_id_next += 1;
	}
	

	
	this.deregister = function(syncable) {
		throw 'Not yet implemented.'
		
		listeners = syncable.listeners('change')
		for (i in listeners) {
			syncable.removeListener('change',listeners[i])
		}
		
		delete self.syncables[syncable[sync_id_]];
		delete syncable[sync_id_];
	}


	this.client_syncable_listeners = {}
	this.on_client_syncable_event = function(event,listener) {
		self.client_syncable_listeners[event] = listener;
	}
	
	this.message = function(message,client_session_id) {
		self.socketServer.clients[client_session_id].send(message)
	}
	
	this.message_all = function(message) {
		for (i in self.socketServer.clients) {
			self.socketServer.clients[i].send(message)

		}
	}
	
	this.message_all_except = function(message,client_session_id) {
		for (i in self.socketServer.clients) {
			if (i != client_session_id) {
				self.socketServer.clients[i].send(message)
			}
		}
	}
	
	/* Setup event for changed syncables on the client side */
	this.on_client_syncable_event(syncable_changed_,function(client,syncable,args) {
				
		server_syncable = self.syncables[syncable[sync_id_]]
				
		if (!server_syncable) {
			sys.puts("Syncable referenced in event from client not found!")
		} else {
			server_syncable.change(syncable)
		}
	})
	
	/* Setup event for newly created syncables on the client side */
	this.on_client_syncable_event(new_syncable_,function(client,syncable,args) {
		
		temp_id = syncable[sync_id_]
		self.register(syncable)
			
	})
	

	
}
util.inherits(SyncServer, events.EventEmitter)



/* CLIENT_SIDE */

var SyncClient = this.SyncClient = function(host,options) {
	
	self = this;
	
	this.syncables = {};
	
	this.socket = new io.Socket(host,options);
	
	this.connect = function() {
		self.socket.connect();
	}
	
	/* Message handler */
	this.socket.on('message', function(message) {
		obj = JSON.parse(message);
		
		/* Handler generic events */
		if (obj[sync_event_]) {
			event = obj[sync_event_].shift() // First item is event
			listener = self.once[event]
			if (listener) {
				delete self.once[event]
			} else {
				listener = self.listeners[event]
			}
			if (listener) {
				listener.apply(listener,obj[sync_event_]) // Rest of items are args for event
			}
			
		/* Handle syncable objects events */
		} else if (obj[syncable_event_]) {
			
			sync_event = obj[syncable_event_];
			listener = self.server_syncable_listeners[sync_event];
			listener(obj['syncable'],obj['argument'])
			
		}
	})
	
	
	
	/* GENERIC SYNC EVENTS */
	
	this.listeners = {}
	this.once = {}
	this.on = function(event,listener) {
		self.listeners[event] = listener;
	}
	
	this.once = function(event,listener) {
		self.once[event] = listener;
	}
	
	this.emit = function(event,args) {
		args.unshift(event)
		self.socket.send(JSON.stringify({sync_event_:args}))
	}
	
	
	
	
	/* SYNCABLES */
	
	this.syncables = {}
	this.register = function(syncable) {
		
		// We'll use a temporary ID for this syncable until we get one from the server
		temp_id = temp_id_prefix_ + Math.random()
		self.syncables[temp_id] = syncable;
		self.syncable[sync_id_] = temp_id
		
		syncable.on('change',function() {
			self.socket.send(
				build_syncable_event_message(syncable_changed_,syncable)
			)
		})
		
		self.on_server_syncable_event(server_set_id_,function(dummy_syncable,arguments) {
			// The server gave us an authoritative ID for this object. Save it.
			delete syncables[sync_id_];
			syncable[synd_id_] = arguments[0];
			syncables[arguments[0]] = syncable;
		})
		
		/* Ask the server for an authoritative id for this syncable */
		self.socket.send(
			build_syncable_event_message(syncable_new_,syncable)
		)
		
	}
	
	this.deregister = function(syncable) {
		throw 'Not yet implemented!';
	}
	
	this.server_syncable_listeners = {}
	this.on_server_syncable_event = function(event,listener) {
		this.server_syncable_listeners[event].listener;
	}
	
	
	
	
	
}


MODULE_NAME = 'SocketSyncr (Server)';

// CLIENT_SIDE = typeof(alert) != 'undefined'

var log = function(msg) {
	require('sys').puts(MODULE_NAME + ': '+msg)
}



/* Import Node.js modules */
var sys = require("sys"),
	util = require('util'),
	http = require("http"),
	io = require("socket.io"),
	events = require('events'),
	url = require('url'),
	fs = require('fs'),
	client = require('node.client');
	
var shared = require('./shared');


/*
var shared.SYNC_EVENT_ = 'sync_event_message_';

var shared.SYNCABLE_EVENT_ = 'syncable_event_'
var sync_id_ = 'sync_id_';


var shared.SYNCABLE_CHANGED_ = 'syncable_changed_';
var shared.NEW_SYNCABLE_ = 'new_syncable_';
var shared.INITIAL_SYNCABLES_ = 'initial_syncables_';
var shared.SERVER_SET_ID_ = 'server_set_id_'



var shared.TEMP_ID_PREFIX = 'temp-id--'


var shared.build_syncable_event_message = function(event,syncable,arguments) {
	return JSON.stringify({syncable_event_:event,
			'syncable':syncable,
			'arguments':arguments
		})
}
*/

var response_from_file = function(response,path,content_type) {
	
	var body = fs.readFileSync(path);
	
	headers = {'Content-Length':body.length}
	
	if (!content_type) {
		if (path.substr(-3) === '.js')
			content_type = 'application/javascript';
		else if (path.substr(-4) === '.html')
			content_type = 'text/html';
	}
	
	if (content_type) {
		headers['Content-Type'] = content_type
	}
	
	response.writeHead(200, headers)
	response.write(body)
	response.end()
}


var error_404 = function(response) {
	var body = "<h1>404 Error</h1>";
	response.writeHead(404, {
		'Content-Length':body.length,
		'Content-Type':'text/html'})

	response.write(body)
	response.end()
}


/* SERVER_SIDE */
var SyncServer = exports.SyncServer = function() {
	
	var self = this;
	
	events.EventEmitter.call(this);
	
	this.listen = function(port) {
		self.httpServer.listen(port);
	}
	
	/* Setup HTTP server */
	this.httpServer = http.Server();
	
	
	/* Setup socket.io server */
	this.socketServer = io.listen(this.httpServer);
	
	
	client.listen(this.httpServer);
	
	
	/* Serve the socketsyncr client at /socketsyncr.js */
	this.httpServer.on('request', function(request,response) {
		
		urlpath = url.parse(request.url).pathname
		
		if (urlpath.indexOf('/static/') == 0) {
			log('Handling /static/ request: ' + urlpath)
			try {
				response_from_file(response,'.' + urlpath)
			} catch(e) {
				log('File not found.')
				error_404(response)
			}

		} else if (urlpath == '/') {
			log('Sending "base.html"');
			response_from_file(response,'./static/base.html','text/html');
			
		}

	})
	
	
	
	
	this.client_emitters = {};
	this.socketServer.on('connection', function(client) {
		
		client.on('disconnect', function() {
			delete self.client_emitters[client.sessionId];
		});
		
		var emitter = self.client_emitters[client.sessionId] = events.EventEmitter();
		
		client.on('message',function(msg) {
			
			// Parse message as JSON object
			jso = JSON.parse(msg);
			
			
			/* If this is a generic sync event then re-emit it */
			if (jso[shared.SYNC_EVENT_]) {
				
				emitter.emit.apply(null,jso[shared.SYNC_EVENT_]);

				
			/* If this is a 'syncable' event... */
			} else if (jso[shared.SYNCABLE_EVENT_]) {
				
				sync_event = jso[shared.SYNCABLE_EVENT_]
				if (self.client_syncable_listeners[sync_event]) {
					args = [client]
					if (jso['syncable'])
						args.push(jso['syncable'])
					if (jso['arguments']) {
						for (i in jso['arguments']) {
							args.push(jso['arguments'][i])
						}
					}
					self.client_syncable_listeners[sync_event](args)
					
				};
			};	
		});	
		
		for (i in self.syncables) {
			client.send(
				shared.build_syncable_event_message(shared.NEW_SYNCABLE_,self.syncables[i])
			);
		};
		
	});
	

	
	
	/* GENERIC SYNC EVENTS */
	
	this.on_any_client = function(event,listener) {
		for (i in t.client_emitters) {
			this.on_client(event,listener,i)
		}
	}
	
	this.on_client = function(event,listener,client_session_id) {
		return self.client_emitters[client_session_id].on(event,listener)
	}
	
	this.forward_to_all = function(server_emitter, events) {
		for (i in this.socketServer.clients) {
			self.forward_to(server_emitter,events,i)
		}
	}
	
	this.forward_to = function(server_emitter, events, client_session_id) {
		if (typeof(events) == 'string') {
			events = [events]
		}
		for (j in events) {
			server_emitter.on(events[j], function() {
				arguments.unshift(client_session_id) // Push client_id to start of arg list
				self.send_as_event(arguments)
			})
		}
	}
	
	this.send_as_event = function() { // client_session_id, arg events
		client_session_id = arguments.shift()
		obj = {}; obj[shared.SYNC_EVENT_] = arguments
		self.socketServer.clients[client_session_id].send(JSON.stringify(obj))
	}
	
	this.send_all_as_event = function() {
		for (i in self.socketServer.clients) {
			obj = {}; obj[shared.SYNC_EVENT_] = arguments;
			self.socketServer.clients[i].send(JSON.stringify(obj))		
		}
	}
	
	
	
	
	/* SYNCABLES */
	
	this.syncables = {}
	this.sync_id_next = 0
	
	/* 
	A ``syncable`` must subclass an EventEmitter. When a change to the ``syncable``
	object is made it should emit the `'change'` event--at which time the ``syncable``
	is forwarded to all clients. 
	
	When a change is made on a client the ``syncable`` object will have its `.changed()`
	method called with the client ``syncable`` object passed as the first argument. It
	is the responsibility of the ``syncable`` object to handle the changes properly.
	*/
	this.register = function(syncable,client) {
		
		var temp_id = syncable[shared.SYNC_ID_];
		self.syncables[self.sync_id_next] = syncable;
		syncable[shared.SYNC_ID_] = self.sync_id_next;
		
		syncable.on('change', function() {
			self.message_all_except(
				shared.build_syncable_event_message(shared.SYNCABLE_CHANGED_,syncable), client.sessionId
			)
		})
		
		if (client) {
			self.message_all_except(
				shared.build_syncable_event_message(shared.NEW_SYNCABLE_,syncable), client.sessionId
			);
			self.message(
				shared.build_syncable_event_message(shared.SERVER_SET_ID_,null,[temp_id,self.sync_id_next]), client.sessionId
			)
			
		} else {
			self.message_all(
				shared.build_syncable_event_message(shared.NEW_SYNCABLE_,syncable)
			);
		}
		
		self.sync_id_next += 1;
	}
	

	
	this.deregister = function(syncable) {
		throw 'Not yet implemented.'
		
		listeners = syncable.listeners('change')
		for (i in listeners) {
			syncable.removeListener('change',listeners[i])
		}
		
		delete self.syncables[syncable[sync_id_]];
		delete syncable[sync_id_];
	}


	this.client_syncable_listeners = {}
	this.on_client_syncable_event = function(event,listener) {
		self.client_syncable_listeners[event] = listener;
	}
	
	this.message = function(message,client_session_id) {
		self.socketServer.clients[client_session_id].send(message)
	}
	
	this.message_all = function(message) {
		for (i in self.socketServer.clients) {
			self.socketServer.clients[i].send(message)

		}
	}
	
	this.message_all_except = function(message,client_session_id) {
		for (i in self.socketServer.clients) {
			if (i != client_session_id) {
				self.socketServer.clients[i].send(message)
			}
		}
	}
	
	/* Setup event for changed syncables on the client side */
	this.on_client_syncable_event(shared.SYNCABLE_CHANGED_,function(client,syncable,args) {
				
		server_syncable = self.syncables[syncable[sync_id_]]
				
		if (!server_syncable) {
			log("Syncable referenced in event from client not found!")
		} else {
			server_syncable.change(syncable)
		}
	})
	
	/* Setup event for newly created syncables on the client side */
	this.on_client_syncable_event(shared.NEW_SYNCABLE_,function(client,syncable,args) {
		
		temp_id = syncable[shared.SYNC_ID_]
		self.register(syncable)
			
	})
	

	
}
util.inherits(SyncServer, events.EventEmitter)



/* CLIENT_SIDE */

